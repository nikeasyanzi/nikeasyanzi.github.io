<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>顧客至上 (Customer Obsession) on Craig Yang&#39;s Blog</title>
    <link>https://nikeasyanzi.github.io/tw/tags/%E9%A1%A7%E5%AE%A2%E8%87%B3%E4%B8%8A-customer-obsession/</link>
    <description>Recent content in 顧客至上 (Customer Obsession) on Craig Yang&#39;s Blog</description>
    <generator>Hugo -- 0.147.9</generator>
    <language>tw</language>
    <copyright>PaperMod Contributors</copyright>
    <lastBuildDate>Thu, 05 Feb 2026 10:30:00 +0800</lastBuildDate>
    <atom:link href="https://nikeasyanzi.github.io/tw/tags/%E9%A1%A7%E5%AE%A2%E8%87%B3%E4%B8%8A-customer-obsession/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>誤報啟發法：當軟體必須吸收硬體雜訊 (The False Alarm Heuristic: When Software Must Absorb Hardware Noise)</title>
      <link>https://nikeasyanzi.github.io/tw/posts/when-software-must-absorb-hardware-noise/</link>
      <pubDate>Thu, 05 Feb 2026 10:30:00 +0800</pubDate>
      <guid>https://nikeasyanzi.github.io/tw/posts/when-software-must-absorb-hardware-noise/</guid>
      <description>&lt;h2 id=&#34;簡介-introduction&#34;&gt;簡介 (Introduction)&lt;/h2&gt;
&lt;p&gt;在系統工程中，我們很容易將「技術上正確」視為終點線。&lt;/p&gt;
&lt;p&gt;但我從的經驗中學到，所謂的正確性仍然可能帶來糟糕的客戶體驗——尤其是當你的軟體介於混亂的現實（硬體、韌體、驅動程式）和那些只想要一個清晰訊號的人之間時：&lt;em&gt;到底有沒有出問題？我需要馬上處理嗎？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;這是一個關於尷尬時刻的故事，它教會了我一個簡單的啟發法：有時候，軟體必須吸收硬體雜訊。&lt;/p&gt;
&lt;h2 id=&#34;問題連鎖誤報-the-problem-a-cascade-of-false-alarms&#34;&gt;問題：連鎖誤報 (The Problem: A Cascade of False Alarms)&lt;/h2&gt;
&lt;p&gt;我們運作一個 SSD 監控常駐程式 (daemon)，負責向客戶回報磨損指標。有一天，一位客戶升級通報了一個嚴重問題：他們的機群突然大規模觸發 SSD 磨損警報。&lt;/p&gt;
&lt;p&gt;時間點再糟糕不過了。他們的發布時程是以天計算，而不是以週計算。而且一場「SSD 健康危機」的警報風暴，足以讓所有決策停擺——即使系統實際上是正常的。&lt;/p&gt;
&lt;p&gt;我的直覺反應是標準的工程師反射動作：假設 bug 是我們造成的。&lt;/p&gt;
&lt;p&gt;於是我逐行檢查程式碼。令人沮喪的是，程式碼看起來無懈可擊。我們完全按照設計讀取作業系統訊號並如實回報。&lt;/p&gt;
&lt;p&gt;接著我們發現了令人不安的真相：&lt;strong&gt;訊號本身就是不穩定的 (flaky)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在我們的 daemon 底層，特定的 SSD 韌體會在較低層級產生偽陽性 (false positives)。而我們的軟體——身為「正確」的一方——正盡職地將這種不穩定性放大成面對客戶的警報。&lt;/p&gt;
&lt;p&gt;這造成了一個我不喜歡但無法避免的兩難：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;實作方式是 &lt;strong&gt;技術上正確的&lt;/strong&gt;，但它卻因為產生雜訊而非可執行的資訊，導致我們 &lt;strong&gt;辜負了客戶&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;這位客戶是第一位回報此事件的人，所以我們沒有既定的處理守則 (playbook)。&lt;/li&gt;
&lt;li&gt;硬體供應商的退換貨流程 (RMA process) 需要數週時間。&lt;/li&gt;
&lt;li&gt;客戶的發布就在幾天之後。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;解決方案啟發式過濾器-the-solution-a-heuristic-filter&#34;&gt;解決方案：啟發式過濾器 (The Solution: A Heuristic Filter)&lt;/h2&gt;
&lt;p&gt;我們需要一個快速、安全且誠實的方案。&lt;/p&gt;
&lt;p&gt;所以我實作了一個 &lt;strong&gt;啟發式過濾器 (heuristic filter)&lt;/strong&gt;——也就是一種防抖動 (debouncing) 機制。&lt;/p&gt;
&lt;p&gt;用白話文說：我們不再是一看到單一的「磨損」訊號就發出警報，而是要求訊號必須在多次讀取中（或在一個短時間窗口內）持續存在。如果訊號是暫時性的，且在下一次檢查時消失，我們就將其視為雜訊。如果它持續存在，我們才視為真實情況。&lt;/p&gt;
&lt;p&gt;關鍵的權衡在於延遲 (latency)。我們的 daemon 每隔幾秒檢查一次訊號，所以「確認」訊號的持續性可能會將警報延遲幾秒鐘（有時是幾分鐘，取決於時間窗口）。&lt;/p&gt;
&lt;p&gt;對於 SSD 健康監控來說，這種輕微的延遲是划算的交易。磨損不是毫秒級的緊急事件；它是一種趨勢。在這種情境下，回報稍有延遲但值得信賴的警報，遠比用使用者無法採取行動的雜訊淹沒他們來得好。&lt;/p&gt;
&lt;p&gt;我與主管在溝通框架上達成了一致：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;這是一個務實的修補程式，目的是為了讓發布流程解鎖。我們不是在掩蓋問題——我們是在推動供應商提供永久修正的同時，先抑制雜訊。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;結果解鎖與學習-the-result-unblocked-and-learned&#34;&gt;結果：解鎖與學習 (The Result: Unblocked and Learned)&lt;/h2&gt;
&lt;p&gt;修補程式順利部署。誤報立即停止。客戶如期發布了產品。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
